/*
 * generated by Xtext 2.17.0
 */
package org.xtext.sdu.generator

import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.HashMap
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.sdu.ioT.Device
import org.xtext.sdu.ioT.DeviceType
import org.xtext.sdu.ioT.DeviceTypes
import org.xtext.sdu.ioT.FetchData
import org.xtext.sdu.ioT.Sensor
import org.xtext.sdu.ioT.SensorGetMethod
import org.xtext.sdu.ioT.SensorGroup
import org.xtext.sdu.ioT.SensorType
import org.xtext.sdu.ioT.SensorTypes
import org.xtext.sdu.ioT.Server
import org.xtext.sdu.ioT.FetchDataExpression

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class IoTGenerator extends AbstractGenerator {
	
	private HashMap<String, String> sensorMap = new HashMap<String, String>();

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		//Default libraries for sensors on a LoPy board
		sensorMap.put("gyroscope", "LIS2HH12");
		sensorMap.put("lightsensor", "LTR329ALS01");
		sensorMap.put("altimeter", "MPL3115A2");
		
		for(device : resource.allContents.filter(Device).toIterable)
		{
			fsa.generateFile(device.name + ".py", generatePythonCode(resource, device))			
		}
		
		
		for(server : resource.allContents.filter(Server).toIterable)
		{
			fsa.generateFile(server.name + ".py", generateServerCode(server))
		}
	}
	
	private def String getSensorLibraryName(String sensorName) {
		if(sensorMap.get(sensorName) != null) {
			return sensorMap.get(sensorName);
		} else {
			return sensorName;
		}
	}
	
	protected def generateServerCode(Server server) '''
	#Autogenerated «new SimpleDateFormat("dd-MM-yyyy 'at' HH:mm:ss").format(Calendar.getInstance().getTime()).toString()» by EasyIoT
	import socket,sys
	from _thread import *
	
	def client_recieve(connection):
	    while True:
	        data = connection.recv(2048)
	        print(data)
	
	        if not data:
	            break
	    connection.close()
	host = '«printIp(server)»' 
	port = «server.port.number»
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	
	if __name__ == '__main__':
	    try:
	        s.bind((host, port))
	    except socket.error as e:
	        print(str(e))
	
	    s.listen()
	    print('Easy IoT Server started. Waiting for connection')
	    while True:
	
	        connnection, addr = s.accept()
	        print('connected to: '+addr[0]+':'+str(addr[1]))
	
	        start_new_thread(client_recieve,(connnection,))
	'''
	
	protected def CharSequence printIp(Server server)
		'''«FOR ipNumber : 0..<server.ip.ip.size»«server.ip.ip.get(ipNumber)»«IF ipNumber + 1 < server.ip.ip.size».«ENDIF»«ENDFOR»'''
	
	
	protected def generatePythonCode(Resource resourceRoot, Device scope) '''
	«val communicationSet = resourceRoot.allContents.filter(FetchData).filter[it.destination instanceof Server].size > 0»
	#Autogenerated «new SimpleDateFormat("dd-MM-yyyy 'at' HH:mm:ss").format(Calendar.getInstance().getTime()).toString()» by EasyIoT
	from pysense import Pysense
	«IF communicationSet»
	import socket
	import network
	import time
	«ENDIF»
	«emitSensortypes(resourceRoot)»
	«emitDevicetypes(resourceRoot)»
	py = Pysense()
	«emitSensors(resourceRoot)»«emitDevices(resourceRoot, scope)»
	
	«emitSensorgroup(resourceRoot)»
	
	«emitSensorGetMethod(resourceRoot)»«if (communicationSet) emitCommunicationLogic(resourceRoot, scope)»
	'''
	
	def emitCommunicationLogic(Resource resource, Device scope) '''
	«val fetches = resource.allContents.filter(FetchData).filter[it.destination instanceof Server].filter[it.device == scope]»
	wlan = network.WLAN(mode=network.WLAN.STA)
	«FOR fetchDataWithServer : fetches.toIterable»
	«val server = fetchDataWithServer.destination as Server»	
	wlan.connect('SSID', auth=(network.WLAN.WPA2, 'PASSWORD'), timeout=5000) #insert network SSID and password
	while not wlan.isconnected():
		time.sleep_ms(100)
	«server.name»_HOST = '«printIp(server)»'  # «server.name»'s IP address
	«server.name»_PORT = «server.port.number» # The port used by «server.name»
	«server.name»_addr = socket.getaddrinfo(«server.name»_HOST, «server.name»_PORT)[0][-1]
	«server.name»_s = socket.socket()
	«server.name»_s.connect(«server.name»_addr)
	«server.name»_s.setblocking(True)
	while True:
	   	time.sleep(«(fetchDataWithServer.conExp as FetchDataExpression).duration.time»)
	   	«FOR getMethod : resource.allContents.filter(SensorGetMethod).filter[it.type == (fetchDataWithServer.filter as SensorType)].toIterable»
	   	«server.name»_s.sendall((b'«scope.name»|{0}|'.format(«resource.allContents.filter(Sensor).filter[it.type == fetchDataWithServer.filter as SensorType].head.name».«getMethod.method.name»(«FOR param: getMethod.method.parameters SEPARATOR ','»«param»«ENDFOR»))))
	   	«ENDFOR»
	«ENDFOR»
	'''
	
	
	def emitSensorGetMethod(Resource resourceRoot) 
	'''
	«IF resourceRoot.allContents.filter(SensorGetMethod).size > 0»
	getMethods = dict()
	«ENDIF»
	«FOR sensorGetMethod : resourceRoot.allContents.filter(SensorGetMethod).toIterable»
	getMethods[«sensorGetMethod.type.name»_«sensorGetMethod.method.name»(«FOR parameter : sensorGetMethod.method.parameters SEPARATOR ','»«parameter»«ENDFOR»)] = getattr(«sensorGetMethod.type.name»,«sensorGetMethod.method.name»(«FOR parameter : sensorGetMethod.method.parameters SEPARATOR ','»«parameter»«ENDFOR»))
	«ENDFOR»
	'''
	
	protected def CharSequence emitSensorgroup(Resource resourceRoot)
		'''«FOR sensorGroup : resourceRoot.allContents.filter(SensorGroup).toIterable»
		«sensorGroup.name» = [«FOR sensor : sensorGroup.sensors SEPARATOR ','»«sensor.name»«ENDFOR»]
		«ENDFOR»'''
	
	
	protected def CharSequence emitSensors(Resource resourceRoot)
		'''«FOR sensor : resourceRoot.allContents.filter(Sensor).toIterable»
		«sensor.name» = «sensor.type.name»(py)
		«ENDFOR»'''
	
	
	protected def CharSequence emitSensortypes(Resource resourceRoot)
		'''«FOR sensorTypes : resourceRoot.allContents.filter(SensorTypes).toIterable»
			«FOR sensorType : sensorTypes.types»
			«sensorType.importSensorLibrary»
			«ENDFOR»
			«ENDFOR»'''
			
			
	protected def CharSequence emitDevicetypes(Resource resourceRoot)
		'''«FOR deviceTypes : resourceRoot.allContents.filter(DeviceTypes).toIterable»
			«FOR deviceType : deviceTypes.types»
			«deviceType.importDeviceLibrary»
			«ENDFOR»
			«ENDFOR»'''
			
	protected def CharSequence emitDevices(Resource resourceRoot, Device scope)
		'''
		«scope.name» = «scope.type.name»()'''
	
	protected def importSensorLibrary(SensorType sensorType) '''	
		from «getSensorLibraryName(sensorType.name)» import «getSensorLibraryName(sensorType.name)» as «sensorType.name»
		'''
	
	protected def importDeviceLibrary(DeviceType deviceType) '''	
		import «deviceType.name» from «deviceType.name»
	'''
}
